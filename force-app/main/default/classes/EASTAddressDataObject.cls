/**
 * Class for parsing EAST Address Response
 *
 * Basis structure JSON Parser generated by JSON2Apex http://json2apex.herokuapp.com/
 *
 * Modified for subaddress parsing.
 *
 * IMPORTANT: DO NOT REPLACE THIS CODE WITH AUTO GENERATED PARSER
 *
 */
public with sharing class EASTAddressDataObject {

	public static void consumeObject(JSONParser parser) {
		Integer depth = 0;
		do {
			JSONToken curr = parser.getCurrentToken();
			if (curr == JSONToken.START_OBJECT ||
			        curr == JSONToken.START_ARRAY) {
				depth++;
			} else if (curr == JSONToken.END_OBJECT ||
			           curr == JSONToken.END_ARRAY) {
				depth--;
			}
		} while (depth > 0 && parser.nextToken() != null);
	}

	public List<EASTAddress> data {get; set;}

	public EASTAddressDataObject(JSONParser parser) {
		Integer numOfAddress = 0;
		while (parser.nextToken() != JSONToken.END_OBJECT) {
			boolean parseEnd = false;
			if (parser.getCurrentToken() == JSONToken.FIELD_NAME) {
				String text = parser.getText();
				if (parser.nextToken() != JSONToken.VALUE_NULL) {
					if (text == 'data') {
						data = new List<EASTAddress>();
						while (parser.nextToken() != JSONToken.END_ARRAY) {

							EASTAddress mainAddress = new EASTAddress(parser);
							String addressCount = mainAddress.numberOfSubAddresses;
							String envResultListWarningLimit = EnvironmentVariable.get('okapi_east_result_list_warning_limit');
							Integer  adddressListLimit = (envResultListWarningLimit != null && envResultListWarningLimit != '') ? integer.valueof(envResultListWarningLimit) : 1000;


							String envVarStatus = EnvironmentVariable.get('okapi_east_address_status');
							envVarStatus = (envVarStatus != null && envVarStatus != '') ? envVarStatus : 'CONFIRMED';

							List<String> envStatusList = envVarStatus.split(',');
							Set<String> envStatusSet = new Set<String>(envStatusList);


							if (envStatusSet.contains(mainAddress.status)) {

								numOfAddress += (addressCount != null && addressCount != '' && Integer.valueOf(addressCount) > 0) ? Integer.valueOf(addressCount) + 1 : 1;
								data.add(mainAddress);
							}
							//Stopping the parsing for address after total of Limit size mentioned in custom settings
							System.debug('numOfAddress-->' + numOfAddress + 'adddressListLimit-->' + adddressListLimit);
							if (numOfAddress >= adddressListLimit) {
								parseEnd = true;
								break;
							}
						}
						if (parseEnd) {
							break;
						}
					} else {
						System.debug(LoggingLevel.WARN, 'Root consuming unrecognized property: ' + text);
						consumeObject(parser);
					}
				}
			}
		}
	}

	public class ServiceLocation {
		public String connectivityServiceAreaId {get; set;}
		public String locationId {get; set;}
		public String exchangeServiceAreaId {get; set;}
		public String facsRealm {get; set;}
		// RFS date added as part of NFB-1218
        	public String readyForServiceDate {get;set;}

		public ServiceLocation(JSONParser parser) {
			while (parser.nextToken() != JSONToken.END_OBJECT) {
				if (parser.getCurrentToken() == JSONToken.FIELD_NAME) {
					String text = parser.getText();
					if (parser.nextToken() != JSONToken.VALUE_NULL) {
						if (text == 'connectivityServiceAreaId') {
							connectivityServiceAreaId = parser.getText();
						} else if (text == 'locationId') {
							locationId = parser.getText();
						} else if (text == 'exchangeServiceAreaId') {
							exchangeServiceAreaId = parser.getText();
						} else if (text == 'facsRealm') {
							facsRealm = parser.getText();
						}
			                        else if (text == 'readyForServiceDate') {     // Owner:Akshay Deuskar | Date: 24-May-17 |  
                            				readyForServiceDate = parser.getText();   // Logic added for RFS date field as part of US NFB-1218
						} else {
							System.debug(LoggingLevel.WARN, 'ServiceLocation consuming unrecognized property: ' + text);
							consumeObject(parser);
						}
					}
				}
			}
		}
	}

	public class EASTAddress {

		public String greaterLocality {get; set;}
		public ServiceLocation serviceLocation {get; set;}
		public String numberOfSubAddresses {get; set;}
		public String localityAbbreviation {get; set;}
		public String state {get; set;}
		public String longZ {get; set;} // in json: long
		public String id {get; set;}
		public String name {get; set;}
		public String ruralMailType {get; set;}
		public String numberTo {get; set;}
		public String planNumber {get; set;}
		public SubAddress subAddress {get; set;}
		public String streetType {get; set;}
		public String numberSuffix {get; set;}
		public String lat {get; set;}
		public String numberToPrefix {get; set;}
		public String numberPrefix {get; set;}
		public String status {get; set;}
		public String locationDescription {get; set;}
		public String numberZ {get; set;} // in json: number
		public String streetName {get; set;}
		public String addressType {get; set;}
		public String postcode {get; set;}
		public String rangeIncrement {get; set;}
		public String streetTypeSuffix {get; set;}
		public String postalDeliveryType {get; set;}
		public String locality {get; set;}
		public String numberToSuffix {get; set;}
		public String searchConfidence {get; set;}

		public EASTAddress(JSONParser parser) {
			while (parser.nextToken() != JSONToken.END_OBJECT) {
				if (parser.getCurrentToken() == JSONToken.FIELD_NAME) {
					String text = parser.getText();
					if (parser.nextToken() != JSONToken.VALUE_NULL) {
						if (text == 'greaterLocality') {
							greaterLocality = parser.getText();
						} else if (text == 'serviceLocation') {
							serviceLocation = new ServiceLocation(parser);
						} else if (text == 'numberOfSubAddresses') {
							numberOfSubAddresses = parser.getText();
						} else if (text == 'localityAbbreviation') {
							localityAbbreviation = parser.getText();
						} else if (text == 'state') {
							state = parser.getText();
						} else if (text == 'long') {
							longZ = parser.getText();
						} else if (text == 'id') {
							id = parser.getText();
						} else if (text == 'name') {
							name = parser.getText();
						} else if (text == 'ruralMailType') {
							ruralMailType = parser.getText();
						} else if (text == 'numberTo') {
							numberTo = parser.getText();
						} else if (text == 'planNumber') {
							planNumber = parser.getText();
						} else if (text == 'subAddress') {

							if (numberOfSubAddresses != null && numberOfSubAddresses != '' && numberOfSubAddresses != '0' && Integer.valueOf(numberOfSubAddresses) > 0) {
								subAddress = new SubAddress(parser);
							}

						} else if (text == 'streetType') {
							streetType = parser.getText();
						} else if (text == 'numberSuffix') {
							numberSuffix = parser.getText();
						} else if (text == 'lat') {
							lat = parser.getText();
						} else if (text == 'numberToPrefix') {
							numberToPrefix = parser.getText();
						} else if (text == 'numberPrefix') {
							numberPrefix = parser.getText();
						} else if (text == 'status') {
							status = parser.getText();
						} else if (text == 'locationDescription') {
							locationDescription = parser.getText();
						} else if (text == 'number') {
							numberZ = parser.getText();
						} else if (text == 'streetName') {
							streetName = parser.getText();
						} else if (text == 'addressType') {
							addressType = parser.getText();
						} else if (text == 'postcode') {
							postcode = parser.getText();
						} else if (text == 'rangeIncrement') {
							rangeIncrement = parser.getText();
						} else if (text == 'streetTypeSuffix') {
							streetTypeSuffix = parser.getText();
						} else if (text == 'postalDeliveryType') {
							postalDeliveryType = parser.getText();
						} else if (text == 'locality') {
							locality = parser.getText();
						} else if (text == 'numberToSuffix') {
							numberToSuffix = parser.getText();
						} else if (text == 'searchConfidence') {
							searchConfidence = parser.getText();
						} else {
							System.debug(LoggingLevel.WARN, 'Data consuming unrecognized property: ' + text);
							consumeObject(parser);
						}
					}
				}
			}
		}
	}

	public class SubAddressComponents {
		public String id {get; set;}
		public String streetTypeSuffix {get; set;}
		public String parentAddressId {get; set;}
		public String subAddressType {get; set;}
		public String streetName {get; set;}
		public String numberZ {get; set;} // in json: number
		public String streetType {get; set;}
		public List<SubAddressComponents> subAddressComponents {get; set;}

		public SubAddressComponents(JSONParser parser) {
			while (parser.nextToken() != JSONToken.END_OBJECT) {
				if (parser.getCurrentToken() == JSONToken.FIELD_NAME) {
					String text = parser.getText();
					if (parser.nextToken() != JSONToken.VALUE_NULL) {
						if (text == 'id') {
							id = parser.getText();
						} else if (text == 'streetTypeSuffix') {
							streetTypeSuffix = parser.getText();
						} else if (text == 'parentAddressId') {
							parentAddressId = parser.getText();
						} else if (text == 'subAddressType') {
							subAddressType = parser.getText();
						} else if (text == 'streetName') {
							streetName = parser.getText();
						} else if (text == 'number') {
							numberZ = parser.getText();
						} else if (text == 'streetType') {
							streetType = parser.getText();
						} else if (text == 'subAddressComponents') {

							subAddressComponents = new List<SubAddressComponents>();

							if (parser.getCurrentToken() == JSONToken.START_OBJECT) {
								subAddressComponents.add(new SubAddressComponents(parser));
							} else {
								while (parser.nextToken() != JSONToken.END_ARRAY) {
									subAddressComponents.add(new SubAddressComponents(parser));
								}
							}
						} else {
							System.debug(LoggingLevel.WARN, 'SubAddressComponents consuming unrecognized property: ' + text);
							consumeObject(parser);
						}
					}
				}
			}
		}
	}

	public class SubAddress {

		public List<SubAddressComponents> subAddressComponents {get; set;}

		public SubAddress(JSONParser parser) {
			while (parser.nextToken() != JSONToken.END_OBJECT) {
				if (parser.getCurrentToken() == JSONToken.FIELD_NAME) {
					String text = parser.getText();
					if (parser.nextToken() != JSONToken.VALUE_NULL) {
						if (text == 'subAddressComponents') {

							subAddressComponents = new List<SubAddressComponents>();

							if (parser.getCurrentToken() == JSONToken.START_OBJECT) {
								subAddressComponents.add(new SubAddressComponents(parser));
							} else {
								while (parser.nextToken() != JSONToken.END_ARRAY) {
									subAddressComponents.add(new SubAddressComponents(parser));
								}
							}
						} else {
							System.debug(LoggingLevel.WARN, 'SubAddress consuming unrecognized property: ' + text);
							consumeObject(parser);
						}
					}
				}
			}
		}
	}


	public static EASTAddressDataObject parse(String json) {
		return new EASTAddressDataObject(System.JSON.createParser(json));
	}
}